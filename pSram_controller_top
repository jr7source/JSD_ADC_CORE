// APS6408L Octal DDR PSRAM Controller for GW5AT-LV138
// 64Mb (8MB) PSRAM with Octal DDR interface
// Supports dual read/write operations 

module psram_controller #(
    parameter ADDR_WIDTH = 23,  // 8MB = 2^23 bytes
    parameter DATA_WIDTH = 32,  // 32-bit internal data bus
    parameter CLK_FREQ_MHZ = 133 // Target frequency (adjust based on your system clock)
)(
    // System interface
    input  wire                    clk,
    input  wire                    rst_n,
    
    // User interface
    input  wire                    cmd_valid,
    output reg                     cmd_ready,
    input  wire                    cmd_write,
    input  wire [ADDR_WIDTH-1:0]   cmd_addr,
    input  wire [DATA_WIDTH-1:0]   cmd_wdata,
    input  wire [DATA_WIDTH/8-1:0] cmd_wmask,
    input  wire [7:0]              cmd_burst_len, // Burst length in bytes
    output reg                     resp_valid,
    input  wire                    resp_ready,
    output reg  [DATA_WIDTH-1:0]   resp_rdata,
    output reg                     resp_error,
    
    // PSRAM interface (Octal DDR)
    output reg                     psram_ce_n,
    output reg                     psram_clk,
    output reg                     psram_rst_n,
    inout  wire [7:0]              psram_dq,
    inout  wire                    psram_dqs_dm,
    
    // Status
    output reg                     init_done,
    output reg [3:0]               status
);

    // Commands from datasheet
    localparam CMD_SYNC_READ        = 8'h00;
    localparam CMD_SYNC_WRITE       = 8'h80;
    localparam CMD_LINEAR_READ      = 8'h20;
    localparam CMD_LINEAR_WRITE     = 8'hA0;
    localparam CMD_MODE_REG_READ    = 8'h40;
    localparam CMD_MODE_REG_WRITE   = 8'hC0;
    localparam CMD_GLOBAL_RESET     = 8'hFF;
    
    // Mode registers
    localparam MR0_ADDR = 8'h00;
    localparam MR4_ADDR = 8'h04;
    localparam MR8_ADDR = 8'h08;
    
    // State machine
    typedef enum logic [4:0] {
        IDLE,
        POWER_UP_WAIT,
        GLOBAL_RESET,
        RESET_WAIT,
        CONFIG_MR0,
        CONFIG_MR4,
        CONFIG_MR8,
        READY,
        CMD_START,
        CMD_SEND,
        ADDR_SEND,
        WRITE_DATA,
        READ_WAIT,
        READ_DATA,
        COMPLETE
    } state_t;
    
    state_t state, next_state;
    
    // Internal registers
    reg [31:0] init_counter;
    reg [7:0]  cmd_reg;
    reg [31:0] addr_reg;
    reg [7:0]  data_buffer [0:31];
    reg [5:0]  byte_counter;
    reg [7:0]  burst_counter;
    reg        dq_oe;
    reg        dqs_oe;
    reg [7:0]  dq_out;
    reg        dqs_out;
    reg [3:0]  latency_counter;
    reg [7:0]  config_data;
    reg        double_clk;
    
    // DDR clock generation
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            double_clk <= 1'b0;
        end else begin
            double_clk <= ~double_clk;
        end
    end
    
    assign psram_clk = (state != IDLE && state != POWER_UP_WAIT) ? double_clk : 1'b0;
    
    // Bidirectional I/O 
    assign psram_dq = dq_oe ? dq_out : 8'hzz;
    assign psram_dqs_dm = dqs_oe ? dqs_out : 1'bz;
    
    //F State machine
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
        end else begin
            state <= next_state;
        end
    end
    
    // Next state logic
    always @(*) begin
        next_state = state;
        case (state)
            IDLE: begin
                if (rst_n) next_state = POWER_UP_WAIT;
            end
            
            POWER_UP_WAIT: begin
                if (init_counter >= 32'd20000) // 150us at 133MHz
                    next_state = GLOBAL_RESET;
            end
            
            GLOBAL_RESET: begin
                if (byte_counter >= 6'd4) // 4 clock cycles for global reset
                    next_state = RESET_WAIT;
            end
            
            RESET_WAIT: begin
                if (init_counter >= 32'd266) // 2us at 133MHz
                    next_state = CONFIG_MR0;
            end
            
            CONFIG_MR0: begin
                if (byte_counter >= 6'd3) // Command + address + data
                    next_state = CONFIG_MR4;
            end
            
            CONFIG_MR4: begin
                if (byte_counter >= 6'd3)
                    next_state = CONFIG_MR8;
            end
            
            CONFIG_MR8: begin
                if (byte_counter >= 6'd3)
                    next_state = READY;
            end
            
            READY: begin
                if (cmd_valid) next_state = CMD_START;
            end
            
            CMD_START: begin
                next_state = CMD_SEND;
            end
            
            CMD_SEND: begin
                if (byte_counter >= 6'd1)
                    next_state = ADDR_SEND;
            end
            
            ADDR_SEND: begin
                if (byte_counter >= 6'd4) begin
                    if (cmd_reg[7]) // Write command
                        next_state = WRITE_DATA;
                    else
                        next_state = READ_WAIT;
                end
            end
            
            WRITE_DATA: begin
                if (burst_counter >= cmd_burst_len - 1)
                    next_state = COMPLETE;
            end
            
            READ_WAIT: begin
                if (latency_counter >= 4'd5) // Latency cycles
                    next_state = READ_DATA;
            end
            
            READ_DATA: begin
                if (burst_counter >= cmd_burst_len - 1)
                    next_state = COMPLETE;
            end
            
            COMPLETE: begin
                next_state = READY;
            end
            
            default: next_state = IDLE;
        endcase
    end
    
    // Central control logic
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            psram_ce_n <= 1'b1;
            psram_rst_n <= 1'b0;
            init_counter <= 32'd0;
            byte_counter <= 6'd0;
            burst_counter <= 8'd0;
            latency_counter <= 4'd0;
            cmd_ready <= 1'b0;
            resp_valid <= 1'b0;
            resp_error <= 1'b0;
            init_done <= 1'b0;
            dq_oe <= 1'b0;
            dqs_oe <= 1'b0;
            dq_out <= 8'h00;
            dqs_out <= 1'b0;
            status <= 4'h0;
        end else begin
            // Default assignments
            cmd_ready <= 1'b0;
            if (resp_valid && resp_ready) resp_valid <= 1'b0;
            
            case (state)
                IDLE: begin
                    psram_rst_n <= 1'b0;
                    psram_ce_n <= 1'b1;
                    init_counter <= 32'd0;
                    status <= 4'h1;
                end
                
                POWER_UP_WAIT: begin
                    psram_rst_n <= 1'b1;
                    psram_ce_n <= 1'b1;
                    init_counter <= init_counter + 1;
                    status <= 4'h2;
                end
                
                GLOBAL_RESET: begin
                    psram_ce_n <= 1'b0;
                    dq_oe <= 1'b1;
                    dq_out <= CMD_GLOBAL_RESET;
                    byte_counter <= byte_counter + 1;
                    status <= 4'h3;
                end
                
                RESET_WAIT: begin
                    psram_ce_n <= 1'b1;
                    dq_oe <= 1'b0;
                    if (init_counter < 32'd266) begin
                        init_counter <= init_counter + 1;
                    end else begin
                        byte_counter <= 6'd0;
                    end
                    status <= 4'h4;
                end
                
                CONFIG_MR0: begin
                    psram_ce_n <= 1'b0;
                    dq_oe <= 1'b1;
                    dqs_oe <= 1'b1;
                    case (byte_counter)
                        6'd0: dq_out <= CMD_MODE_REG_WRITE;
                        6'd1: dq_out <= MR0_ADDR;
                        6'd2: dq_out <= 8'h12; // Latency 5, Drive strength 50ohm
                        default: dq_out <= 8'h00;
                    endcase
                    byte_counter <= byte_counter + 1;
                    status <= 4'h5;
                end
                
                CONFIG_MR4: begin
                    psram_ce_n <= 1'b0;
                    dq_oe <= 1'b1;
                    dqs_oe <= 1'b1;
                    case (byte_counter)
                        6'd0: dq_out <= CMD_MODE_REG_WRITE;
                        6'd1: dq_out <= MR4_ADDR;
                        6'd2: dq_out <= 8'h40; // Write latency 5
                        default: dq_out <= 8'h00;
                    endcase
                    if (byte_counter < 6'd3) begin
                        byte_counter <= byte_counter + 1;
                    end else begin
                        byte_counter <= 6'd0;
                    end
                    status <= 4'h6;
                end
                
                CONFIG_MR8: begin
                    psram_ce_n <= 1'b0;
                    dq_oe <= 1'b1;
                    dqs_oe <= 1'b1;
                    case (byte_counter)
                        6'd0: dq_out <= CMD_MODE_REG_WRITE;
                        6'd1: dq_out <= MR8_ADDR;
                        6'd2: dq_out <= 8'h05; // 32-byte hybrid wrap
                        default: dq_out <= 8'h00;
                    endcase
                    if (byte_counter < 6'd3) begin
                        byte_counter <= byte_counter + 1;
                    end else begin
                        byte_counter <= 6'd0;
                        init_done <= 1'b1;
                    end
                    status <= 4'h7;
                end
                
                READY: begin
                    psram_ce_n <= 1'b1;
                    dq_oe <= 1'b0;
                    dqs_oe <= 1'b0;
                    cmd_ready <= 1'b1;
                    status <= 4'h8;
                end
                
                CMD_START: begin
                    psram_ce_n <= 1'b0;
                    cmd_reg <= cmd_write ? CMD_SYNC_WRITE : CMD_SYNC_READ;
                    addr_reg <= {cmd_addr, 1'b0}; // Ensure even address
                    byte_counter <= 6'd0;
                    burst_counter <= 8'd0;
                    latency_counter <= 4'd0;
                    // Store write data in buffer
                    if (cmd_write) begin
                        data_buffer[0] <= cmd_wdata[7:0];
                        data_buffer[1] <= cmd_wdata[15:8];
                        data_buffer[2] <= cmd_wdata[23:16];
                        data_buffer[3] <= cmd_wdata[31:24];
                    end
                    status <= 4'h9;
                end
                
                CMD_SEND: begin
                    dq_oe <= 1'b1;
                    dq_out <= cmd_reg;
                    byte_counter <= byte_counter + 1;
                    status <= 4'hA;
                end
                
                ADDR_SEND: begin
                    dq_oe <= 1'b1;
                    case (byte_counter)
                        6'd1: dq_out <= addr_reg[31:24]; // A3
                        6'd2: dq_out <= addr_reg[23:16]; // A2
                        6'd3: dq_out <= addr_reg[15:8];  // A1
                        6'd4: dq_out <= addr_reg[7:0];   // A0
                        default: dq_out <= 8'h00;
                    endcase
                    byte_counter <= byte_counter + 1;
                    status <= 4'hB;
                end
                
                WRITE_DATA: begin
                    dq_oe <= 1'b1;
                    dqs_oe <= 1'b1;
                    dqs_out <= double_clk; // Data strobe
                    dq_out <= data_buffer[burst_counter];
                    burst_counter <= burst_counter + 1;
                    status <= 4'hC;
                end
                
                READ_WAIT: begin
                    dq_oe <= 1'b0;
                    dqs_oe <= 1'b0;
                    latency_counter <= latency_counter + 1;
                    status <= 4'hD;
                end
                
                READ_DATA: begin
                    dq_oe <= 1'b0;
                    dqs_oe <= 1'b0;
                    // Capture data on DQS edges
                    if (psram_dqs_dm) begin
                        data_buffer[burst_counter] <= psram_dq;
                        burst_counter <= burst_counter + 1;
                    end
                    status <= 4'hE;
                end
                
                COMPLETE: begin
                    psram_ce_n <= 1'b1;
                    dq_oe <= 1'b0;
                    dqs_oe <= 1'b0;
                    if (!cmd_write) begin
                        resp_valid <= 1'b1;
                        resp_rdata <= {data_buffer[3], data_buffer[2], data_buffer[1], data_buffer[0]};
                    end
                    status <= 4'hF;
                end
            endcase
        end
    end

endmodule

module psram_memory_interface #(
    parameter ADDR_WIDTH = 23,
    parameter DATA_WIDTH = 32
)(
    input  wire                    clk,
    input  wire                    rst_n,
    
    // Memory interface
    input  wire                    mem_valid,
    output wire                    mem_ready,
    input  wire                    mem_write,
    input  wire [ADDR_WIDTH-1:0]   mem_addr,
    input  wire [DATA_WIDTH-1:0]   mem_wdata,
    input  wire [DATA_WIDTH/8-1:0] mem_wmask,
    output wire                    mem_rvalid,
    output wire [DATA_WIDTH-1:0]   mem_rdata,
    output wire                    mem_error,
    
    // PSRAM pins
    output wire                    psram_ce_n,
    output wire                    psram_clk,
    output wire                    psram_rst_n,
    inout  wire [7:0]              psram_dq,
    inout  wire                    psram_dqs_dm,
    
    // Status
    output wire                    init_done
);

    psram_controller #(
        .ADDR_WIDTH(ADDR_WIDTH),
        .DATA_WIDTH(DATA_WIDTH)
    ) u_psram_ctrl (
        .clk(clk),
        .rst_n(rst_n),
        
        .cmd_valid(mem_valid),
        .cmd_ready(mem_ready),
        .cmd_write(mem_write),
        .cmd_addr(mem_addr),
        .cmd_wdata(mem_wdata),
        .cmd_wmask(mem_wmask),
        .cmd_burst_len(8'd4), // Fixed 4-byte bursts for 32-bit interface
        
        .resp_valid(mem_rvalid),
        .resp_ready(1'b1),
        .resp_rdata(mem_rdata),
        .resp_error(mem_error),
        
        .psram_ce_n(psram_ce_n),
        .psram_clk(psram_clk),
        .psram_rst_n(psram_rst_n),
        .psram_dq(psram_dq),
        .psram_dqs_dm(psram_dqs_dm),
        
        .init_done(init_done),
        .status()
    );

endmodule
